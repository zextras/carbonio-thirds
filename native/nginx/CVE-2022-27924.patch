diff '--color=auto' -Naur a/src/core/ngx_memcache.c b/src/core/ngx_memcache.c
--- a/src/core/ngx_memcache.c	2022-06-16 17:11:56.669411179 +0200
+++ b/src/core/ngx_memcache.c	2022-06-16 17:06:54.550798487 +0200
@@ -3,6 +3,7 @@
 
 #define MC_INVALID_HASH ((ngx_uint_t) - 1)
 #define MC_REQ_POOL_SIZE 1024
+#define SHA256_KEY_LENGTH 64
 
 static int mc_sndbuf_len = 256 * 1024;
 
@@ -59,6 +60,7 @@
 /* hashing functions to elect a memcached server for caching */
 static ngx_uint_t ngx_memcache_hash (u_char *key, size_t len);
 static ngx_uint_t ngx_memcache_perl_hash (u_char *key, size_t len);
+static ngx_str_t ngx_sha256_hash (ngx_pool_t* p, u_char *key, size_t len);
 
 /* generic event handler to read any memcache response */
 static void ngx_memcache_any_read_handler (ngx_event_t *rev);
@@ -501,24 +503,26 @@
     mcf = (ngx_memcache_conf_t *)ngx_get_conf(ngx_cycle->conf_ctx, ngx_memcache_module);
     contexts = (mc_context_t *)mcf->contexts.elts;
 
-    h = ngx_memcache_hash(key.data, key.len);
+    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0, "ngx_mc_log, org_key=[%s]", key.data);
+    h = ngx_memcache_hash (key.data, key.len);
 
-    if (h == MC_INVALID_HASH)
-    {
+    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, l, 0,
+        "ngx_mc_log, posting memcache request to cache server #%d", h);
+    mcctx =  contexts + h;
+
+    if (h == MC_INVALID_HASH) {
         ngx_log_error (NGX_LOG_NOTICE, l, 0,
-            "no memcache server available, cannot post request");
+            "ngx_mc_log, no memcache server available, cannot post request");
         w->response_code = mcres_failure_unavailable;
         w->on_failure(w);
         return;
     }
 
-    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, l, 0,
-        "posting memcache request to cache server #%d", h);
-    mcctx =  contexts + h;
-
     if (p == NULL) {
         p = ngx_create_pool(MC_REQ_POOL_SIZE, l);
         if (p == NULL) {
+            ngx_log_error (NGX_LOG_NOTICE, l, 0,
+                "ngx_mc_log, failed to create pool, cannot post request");
             w->response_code = mcres_failure_unavailable;
             w->on_failure(w);
             return;
@@ -526,8 +530,20 @@
         reclaim = 1;
     }
 
+    key = ngx_sha256_hash (p, key.data, key.len);
+    if (0 == key.len || NULL == key.data) {
+        ngx_log_error (NGX_LOG_NOTICE, l, 0,
+            "ngx_mc_log, failed to hash the key, cannot post request");
+        w->response_code = mcres_failure_unavailable;
+        w->on_failure(w);
+        return;
+    }
+    ngx_log_debug1 (NGX_LOG_DEBUG_CORE, ngx_cycle->log, 0, "ngx_mc_log, hashed_key=[%s]", key.data);
+
     pdu = ngx_memcache_create_pdu(p, w, key, value, ttl, l);
     if (pdu.data == NULL) {
+        ngx_log_error (NGX_LOG_NOTICE, l, 0,
+            "ngx_mc_log, failed to create pdu, cannot post request");
         w->response_code = mcres_failure_normal;
         w->on_failure(w);
         return;
@@ -541,6 +557,8 @@
 
     r = ngx_pcalloc(p, sizeof(mc_workqueue_t));
     if (r == NULL) {
+        ngx_log_error (NGX_LOG_NOTICE, l, 0,
+            "ngx_mc_log, failed to allocate memory, cannot post request");
         w->response_code = mcres_failure_unavailable;
         w->on_failure(w);
         return;
@@ -564,7 +582,7 @@
                 ngx_unlock(&mcctx->lock);
 
             ngx_log_error (NGX_LOG_NOTICE, l, 0,
-                    "memcached channel %V orderly shutdown when posting request",
+                    "ngx_mc_log, memcached channel %V orderly shutdown when posting request",
                     mcctx->srvconn->name);
 
             mcctx->status = mcchan_bad;
@@ -600,10 +618,11 @@
 
     ngx_memcache_wq_enqueue (&mcctx->wq_head, r);
 
-    if (locked)
+    if (locked) {
         ngx_unlock(&mcctx->lock);
-    ngx_log_debug2 (NGX_LOG_DEBUG_CORE, l, 0, "posted request(%p) on server #%d",
-                    r, h);
+    }
+    ngx_log_debug2 (NGX_LOG_DEBUG_CORE, l, 0,
+        "ngx_mc_log, posted request(%p) on server #%d", r, h);
 
     return;
 }
@@ -1969,6 +1988,17 @@
     return h;
 }
 
+static ngx_str_t ngx_sha256_hash (ngx_pool_t* p, u_char* key, size_t len)
+{
+    ngx_str_t hashed_key;
+    u_char * digest = ngx_pnalloc(p, SHA256_KEY_LENGTH);
+    SHA256(key, len, digest);
+    hashed_key.data = ngx_memcache_hexstr(digest, SHA256_KEY_LENGTH);
+    hashed_key.len = strlen((const char *)hashed_key.data);
+
+    return hashed_key;
+}
+
 static inline void
 ngx_memcache_prepare_reconnection (mc_context_t * mcctx) {
     ngx_event_t * ev = mcctx->reconnect_ev;
